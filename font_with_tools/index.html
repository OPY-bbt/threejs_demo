<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        body { margin: 0; font-size: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="./dat.js"></script>
    <script>
        /***
         *  rewrite prototype method
         * 
         ***/

        THREE.Font.prototype.generateShapes = function(text, size) {
            if ( size === undefined ) size = 100;

            var shapes = [];
            var paths = createPaths( text, size, this.data );

            for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

                Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

            }

            return shapes;
        }

        function createPaths( text, size, data ) {

            var chars = Array.from ? Array.from( text ) : String( text ).split( '' );
            var scale = size / data.resolution;
            
            // add line-height
            var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale * window.controls.lineHeight;

            var paths = [];

            var offsetX = 0, offsetY = 0;

            for ( var i = 0; i < chars.length; i ++ ) {

                var char = chars[ i ];

                if ( char === '\n' ) {

                    offsetX = 0;
                    offsetY -= line_height;

                } else {

                    var ret = createPath( char, scale, offsetX, offsetY, data );
                    offsetX += ret.offsetX;
                    paths.push( ret.path );

                }

            }

            return paths;

        }

        function createPath( char, scale, offsetX, offsetY, data ) {

            var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

            if ( ! glyph ) {

                console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

                return;

            }

            var path = new THREE.ShapePath();

            var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if ( glyph.o ) {

                var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

                for ( var i = 0, l = outline.length; i < l; ) {

                    var action = outline[ i ++ ];

                    switch ( action ) {

                        case 'm': // moveTo

                            x = outline[ i ++ ] * scale + offsetX;
                            y = outline[ i ++ ] * scale + offsetY;

                            path.moveTo( x, y );

                            break;

                        case 'l': // lineTo

                            x = outline[ i ++ ] * scale + offsetX;
                            y = outline[ i ++ ] * scale + offsetY;

                            path.lineTo( x, y );

                            break;

                        case 'q': // quadraticCurveTo

                            cpx = outline[ i ++ ] * scale + offsetX;
                            cpy = outline[ i ++ ] * scale + offsetY;
                            cpx1 = outline[ i ++ ] * scale + offsetX;
                            cpy1 = outline[ i ++ ] * scale + offsetY;

                            path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                            break;

                        case 'b': // bezierCurveTo

                            cpx = outline[ i ++ ] * scale + offsetX;
                            cpy = outline[ i ++ ] * scale + offsetY;
                            cpx1 = outline[ i ++ ] * scale + offsetX;
                            cpy1 = outline[ i ++ ] * scale + offsetY;
                            cpx2 = outline[ i ++ ] * scale + offsetX;
                            cpy2 = outline[ i ++ ] * scale + offsetY;

                            path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                            break;

                    }

                }

            }

            // add letter-space
            return { offsetX: glyph.ha * scale * window.controls.letterSpace, path: path };

        }
        
    </script>
    <script>
        THREE.Cache.enabled = true;
        var camera, scene, renderer;
        var group, textMesh, textGeo, materials, font;

        var width = window.innerWidth,
            height = window.innerHeight,
            fov = 30,

            bevelThickness = 2,
            bevelSize = 1.5,
            bevelEnabled = true,

            curveSegments = 4,

            textHeight = 10,
            size = 80;

        var targetRotation = 0;
        var targetRotationOnMouseDown = 0;

        var targetRotationX = 0;
        var targetRotationXOnMouseDown = 0;

        var mouseX = 0;
        var mouseXOnMouseDown = 0;

        var mouseY = 0;
        var mouseYOnMouseDown = 0;

        var windowHalfX = width / 2;
        var windowHalfY = height / 2;

        var controls = {
            size: size,
            color: "#00FFBC",
            letterSpace: 1,
            lineHeight: 1,
            bevelEnabled: bevelEnabled,
            text: 'tuguaishou',
            opacity: 1,
            depth: textHeight,
        };

        function init() {
            // CAMERA
            camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
            camera.position.set( 0, 0, 500 );
            cameraTarget = new THREE.Vector3( 0, 0, 0 );

            // SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x000000 );
            scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

            // LIGHTS
            var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
            dirLight.position.set( 0, 0, 1 ).normalize();
            scene.add( dirLight );

            var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
            pointLight.position.set( 0, 100, 90 );
            scene.add( pointLight );

            // GROUP
            group = new THREE.Group();
            group.position.y = 0;
            scene.add( group );

            loadFont();

            // RENDERER
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height );
            document.body.appendChild( renderer.domElement );

            // EVENTS
            renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
            window.addEventListener( 'resize', onWindowResize, false );
        }

        function initGUI() {
            var gui = new dat.GUI();
            var c_mesh_text = gui.add(controls, 'text');
            var c_mesh_size = gui.add(controls, 'size', 50, 150).step(1);
            var c_mesh_color = gui.addColor(controls, 'color', 0,100);
            var c_mesh_letterSpace = gui.add(controls, 'letterSpace', 0.5, 3).step(0.1);
            var c_mesh_lineHeight = gui.add(controls, 'lineHeight', 0.5, 3).step(0.1);
            var c_mesh_opacity = gui.add(controls, 'opacity', 0, 1).step(0.1);
            var c_meth_depth = gui.add(controls, 'depth', 0, 50).step(1);
            var c_mesh_bevelEnabled = gui.add(controls, 'bevelEnabled');

            c_mesh_text.onChange(function() {
                refreshText();
            });

            c_mesh_size.onChange(function(){
                size = controls.size;
                refreshText();
            });

            c_mesh_color.onChange(function(){
                refreshText();
            });

            c_mesh_letterSpace.onChange(function() {
                refreshText();
            });

            c_mesh_lineHeight.onChange(function() {
                refreshText();
            });

            c_mesh_opacity.onChange(function() {
                refreshText();
            });

            c_meth_depth.onChange(function() {
                refreshText();
            });

            c_mesh_bevelEnabled.onChange(function() {
                refreshText();
            });
        }

        function loadFont() {
            var loader = new THREE.FontLoader();
            loader.load( 'font.json', function ( response ) {
                font = response;
                refreshText();
            });
        }

        function refreshText() {
            group.remove( textMesh );

            if ( ! controls.text ) return;

            createText();
        }

        function createText() {
            textGeo = new THREE.TextGeometry( controls.text, {
                font: font,
                size: controls.size,
                height: controls.depth,

                bevelThickness: bevelThickness,
                bevelSize: bevelSize,
                bevelEnabled: controls.bevelEnabled,

                curveSegments: curveSegments,
            });

            textGeo.computeBoundingBox();
            textGeo.computeVertexNormals();

            var centerOffsetX = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
            var centerOffsetY = - 0.5 * ( textGeo.boundingBox.max.y - textGeo.boundingBox.min.y );

            textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );
            textGeo.center();

            // MATERIAL
            var color = controls.color.substring(1);
            materials = [
                new THREE.MeshPhongMaterial( { color: parseInt(color, 16), transparent: true } ), // front
                new THREE.MeshPhongMaterial( { color: parseInt(color, 16), transparent: true } ), // side
            ];
            materials.forEach(function(v) { v.opacity = controls.opacity; });

            textMesh = new THREE.Mesh( textGeo, materials );

            group.add( textMesh );
        }

        function onDocumentMouseDown( event ) {
            event.preventDefault();
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mouseout', onDocumentMouseOut, false );
            mouseXOnMouseDown = event.clientX - windowHalfX;
            mouseYOnMouseDown = event.clientY - windowHalfY;
            targetRotationOnMouseDown = targetRotation;
            targetRotationXOnMouseDown = targetRotationX;

        }

        function onDocumentMouseMove( event ) {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
            targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
            targetRotationX = targetRotationXOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.02;

        }

        function onDocumentMouseUp() {
            document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
            document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
            document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
        }

        function onDocumentMouseOut() {
            document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
            document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
            document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
        }

        function onWindowResize() {
            width = window.innerWidth,
            height = window.innerHeight,

            windowHalfX = width / 2;
            windowHalfY = height / 2;

            camera.left = width / - 2,
            camera.right = width / 2,
            camera.top = height / 2,
            camera.bottom = height / - 2,
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
            group.rotation.x += ( targetRotationX - group.rotation.x) * 0.05;

            camera.lookAt( cameraTarget );
            renderer.clear();
            renderer.render( scene, camera );
        }

        init();
        initGUI();
        animate();
    </script>
</body>
</html>