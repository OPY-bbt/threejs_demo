<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        body { margin: 0; font-size: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
    <script src="ttf2json.js"></script>
    <script src="./three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    <script src="./libtess.min.js"></script>
    <script src="./triangulate.js"></script>
    <script>
        /***
         *  rewrite prototype method
         * 
         ***/

        THREE.Font.prototype.generateShapes = function(text, size) {
            if ( size === undefined ) size = 100;

            var shapes = [];
            var paths = createPaths( text, size, this.data );

            for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

                Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

            }

            return shapes;
        }

        function createPaths( text, size, data ) {

            var chars = Array.from ? Array.from( text ) : String( text ).split( '' );
            var scale = size / data.resolution;
            
            // add line-height
            var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale * window.controls.lineHeight;

            var paths = [];

            var offsetX = 0, offsetY = 0;

            for ( var i = 0; i < chars.length; i ++ ) {

                var char = chars[ i ];

                if ( char === '\n' ) {

                    offsetX = 0;
                    offsetY -= line_height;

                } else {
                    var ret = createPath( char, scale, offsetX, offsetY, char.charCodeAt(0) < 255 ? polyfill_font.data : data );
                    offsetX += ret.offsetX;
                    paths.push( ret.path );

                }

            }

            return paths;

        }

        function createPath( char, scale, offsetX, offsetY, data ) {

            var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

            if ( ! glyph ) {

                console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

                return;

            }

            var path = new THREE.ShapePath();

            var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if ( glyph.o ) {

                var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
                var result = [];

                for ( var i = 0, l = outline.length; i < l; ) {

                    var action = outline[ i ++ ];

                    switch ( action ) {

                        case 'm': // moveTo

                            x = outline[ i ++ ] * scale + offsetX;
                            y = outline[ i ++ ] * scale + offsetY;

                            path.moveTo( x, y );

                            break;

                        case 'l': // lineTo

                            x = outline[ i ++ ] * scale + offsetX;
                            y = outline[ i ++ ] * scale + offsetY;

                            path.lineTo( x, y );

                            break;

                        case 'q': // quadraticCurveTo

                            cpx = outline[ i ++ ] * scale + offsetX;
                            cpy = outline[ i ++ ] * scale + offsetY;
                            cpx1 = outline[ i ++ ] * scale + offsetX;
                            cpy1 = outline[ i ++ ] * scale + offsetY;

                            path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                            break;

                        case 'b': // bezierCurveTo

                            cpx = outline[ i ++ ] * scale + offsetX;
                            cpy = outline[ i ++ ] * scale + offsetY;
                            cpx1 = outline[ i ++ ] * scale + offsetX;
                            cpy1 = outline[ i ++ ] * scale + offsetY;
                            cpx2 = outline[ i ++ ] * scale + offsetX;
                            cpy2 = outline[ i ++ ] * scale + offsetY;

                            path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                            break;
                        case 'z':
                            // path.moveTo( 0, 0 );
                            break;

                    }
                }
                // console.log(path);
                // 0-9 9-14 14-31 31-36 36-41 41

            }
            // path.subPaths = path.subPaths.slice(-1);
            // add letter-space
            return { offsetX: glyph.ha * scale * window.controls.letterSpace, path: path };

        }

        var oldTriangulateShape = THREE.ShapeUtils.triangulateShape;
        THREE.ShapeUtils.triangulateShape = function(cs, holes) {
            var contours = [cs, ...holes];
            var flat_contours = contours.map(contour => contour.map(v => [v.x, v.y]).flat());
            var triangles = triangulate(flat_contours.map(flat_contour => new Float32Array(flat_contour)));
            
            function isEqual(a, b) {
                return Math.abs(a - b) < 1e-1;
            }

            // 1. recover vertex index
            var indexes = [];
            for( var i = 0; i < triangles.length; i += 2) {
                var t1 = triangles[i];
                var t2 = triangles[i + 1];

                var index = contours.flat().findIndex(v => isEqual(v.x, t1) && isEqual(v.y, t2));
                if (index < 0) {
                    console.error("can't find vertex index", t1, t2);
                } else {
                    indexes.push(index);
                }
            }

            // 2. calculate three vertexes in face
            var faces = [];
            for( var i = 0; i < indexes.length; i += 3) {
                faces.push(indexes.slice(i, i+3));
            }

            return faces;
        }
        
    </script>
    <script>
        THREE.Cache.enabled = true;
        var camera, scene, renderer;
        var group, textMesh, textGeo, materials, font;

        var width = window.innerWidth,
            height = window.innerHeight,
            fov = 30,

            bevelThickness = 2,
            bevelSize = 1.5,
            bevelOffset = 0,
            bevelSegments = 3,
            bevelEnabled = true,

            curveSegments = 4,

            textHeight = 10,
            size = 120;

        var targetRotation = 0;
        var targetRotationOnMouseDown = 0;

        var targetRotationX = 0;
        var targetRotationXOnMouseDown = 0;

        var mouseX = 0;
        var mouseXOnMouseDown = 0;

        var mouseY = 0;
        var mouseYOnMouseDown = 0;

        var windowHalfX = width / 2;
        var windowHalfY = height / 2;

        var polyfill_font;

        var font_urls = [
            {
                url: 'alifont.json',
                label: '只有图怪兽三个字',
                type: 'json',
            }, {
                url: 'font.json',
                label: '只有英文',
                type: 'json',
            }, {
                url: 'fnsyhtLight.ttf',
                label: '思源',
                type: 'ttf',
            }, {
                url: 'zh27hbdt.ttf',
                label: '字魂布丁体',
                type: 'ttf',
            }, {
                url: 'zh.ttf',
                label: '字魂',
                type: 'ttf',
            }, {
                url: './aliph.woff',
                label: '阿里普惠字体DEMO文字',
                type: 'woff',
            }, {
                url: 'https://js.tuguaishou.com/fonts/fnsystSCHeavy.woff?t=1555041828',
                label: "思源宋体",
                type: 'woff',
            }, {
                url: 'https://js.tuguaishou.com/fonts/zh35hsxheht.woff?t=1555041828',
                label: "字魂35号经典雅黑",
                type: 'woff',
            }, {
                url: 'https://st0.dancf.com/csc/1/fonts/227/20180417-014250-11.woff',
                label: "思源黑体中等",
                type: 'woff',
            }, {
                url: 'https://st0.dancf.com/csc/156/fonts/0/20190430-011812-558f.woff',
                label: "潮字杜小",
                type: 'woff',
            }
        ];

        var controls = {
            size: size,
            frontColor: "#FFFFFF",
            sideColor: '#FFFFFF',
            letterSpace: 1,
            lineHeight: 1,

            bevelEnabled: bevelEnabled,
            bevelOffset: bevelOffset,
            bevelSegments: bevelSegments,

            text: '图怪兽',
            fontFamily: '思源宋体',
            depth: textHeight,

            // material-front
            frontTextureEnabled: false,
            frontOpacity: 1,

            // material-side
            sideTextureEnabled: false,
            sideOpacity: 1,

            // light
            directional_light_enabled: true,
            directional_light_color: 0xffffff,
            directional_light_intensity: 0.125,
            directional_light_x: 0,
            directional_light_y: 0,
            directional_light_z: 1,

            point_light_enabled: true,
            point_light_color: 0xffffff,
            point_light_intensity: 1.5,
            point_light_x: 0,
            point_light_y: 200,
            point_light_z: 90,
        };

        function init() {
            // CAMERA
            camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
            camera.position.set( 0, 0, 500 );
            cameraTarget = new THREE.Vector3( 0, 0, 0 );

            // SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xFFFFFF );
            scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

            // LIGHTS
            var dirLight = new THREE.DirectionalLight( controls.directional_light_color, controls.directional_light_intensity );
            dirLight.position.set( controls.directional_light_x, controls.directional_light_y, controls.directional_light_z ).normalize();
            scene.add( dirLight );

            var pointLight = new THREE.PointLight( controls.point_light_color, controls.point_light_intensity );
            pointLight.position.set( controls.point_light_x, controls.point_light_y, controls.point_light_z );
            scene.add( pointLight );

            // GROUP
            group = new THREE.Group();
            group.position.y = 0;
            scene.add( group );

            loadFontNormalFont();

            // RENDERER
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height );
            document.body.appendChild( renderer.domElement );

            // EVENTS
            renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
            renderer.domElement.addEventListener( 'touchstart', onDocumentMouseDown, false );
            window.addEventListener( 'resize', onWindowResize, false );
        }

        function initGUI() {
            var gui = new dat.GUI({width: 300});
            var c_mesh_text = gui.add(controls, 'text').onChange(loadFont);
            var c_mesh_size = gui.add(controls, 'size', 50, 150).step(1).onChange(refreshText);
            var c_mesh_letterSpace = gui.add(controls, 'letterSpace', 0.5, 3).step(0.1).onChange(refreshText);
            var c_mesh_lineHeight = gui.add(controls, 'lineHeight', 0.5, 3).step(0.1).onChange(refreshText);
            var c_mesh_fontFamily = gui.add(controls, 'fontFamily', font_urls.map(v => v.label)).onChange(loadFont);
            var c_meth_depth = gui.add(controls, 'depth', 0, 50).step(1).onChange(refreshText);
            var c_mesh_bevelEnabled = gui.add(controls, 'bevelEnabled').onChange(refreshText);

            // LIGHT CONFIG
            var directional_light_folder = gui.addFolder('directional_light(平行光)');
            var directional_light = scene.children[0];
            directional_light_folder.add(controls, 'directional_light_enabled').onChange(function(v) {
                directional_light.visible = v;
            });
            directional_light_folder.addColor(controls, 'directional_light_color', 0,100).onChange(function(v) {
                directional_light.color.setHex( v );
            });
            directional_light_folder.add(controls, 'directional_light_x').step(1).onChange(function(v) {
                directional_light.position.setX(v);
            });
            directional_light_folder.add(controls, 'directional_light_y').step(1).onChange(function(v) {
                directional_light.position.setY(v);
            });
            directional_light_folder.add(controls, 'directional_light_z').step(1).onChange(function(v) {
                directional_light.position.setZ(v);
            });
            directional_light_folder.add(controls, 'directional_light_intensity').onChange(function(v) {
                directional_light.intensity = v;
            });
            // directional_light_folder.open();

            var point_light_folder = gui.addFolder('point_light(点光源)');
            var point_light = scene.children[1];
            point_light_folder.add(controls, 'point_light_enabled').onChange(function(v) {
                point_light.visible = v;
            });
            point_light_folder.addColor(controls, 'point_light_color', 0,100).onChange(function(v) {
                point_light.color.setHex( v );
            });
            point_light_folder.add(controls, 'point_light_x').step(1).onChange(function(v) {
                point_light.position.setX(v);
            });
            point_light_folder.add(controls, 'point_light_y').step(1).onChange(function(v) {
                point_light.position.setY(v);
            });
            point_light_folder.add(controls, 'point_light_z').step(1).onChange(function(v) {
                point_light.position.setZ(v);
            });
            point_light_folder.add(controls, 'point_light_intensity').onChange(function(v) {
                point_light.intensity = v;
            });
            // point_light_folder.open();

             // MATERIAL CONFIG
            var front_material_folder = gui.addFolder('front_material(控制文字正面颜色)');
            front_material_folder.addColor(controls, 'frontColor', 0,100).onChange(refreshText);
            front_material_folder.add(controls, 'frontTextureEnabled').onChange(refreshText);
            front_material_folder.add(controls, 'frontOpacity', 0, 1).step(0.1).onChange(refreshText);
            // front_material_folder.open();

            var side_material_folder = gui.addFolder('side_matertial(控制文字侧面颜色)');
            side_material_folder.addColor(controls, 'sideColor', 0, 100).onChange(refreshText);
            side_material_folder.add(controls, 'sideTextureEnabled').onChange(refreshText);
            side_material_folder.add(controls, 'sideOpacity', 0, 1).step(0.1).onChange(refreshText);
            // side_material_folder.open();
        }

        function loadFontNormalFont() {
            var loader = new THREE.FontLoader();
            loader.load( 'font.json', function ( response ) {
                polyfill_font = response;

                loadFont();
            });
        }

        function loadFont() {
            var loader = new THREE.FontLoader();
            var targetFont = font_urls.find(v => v.label === controls.fontFamily);

            if (!targetFont) {
                return;
            }

            switch(targetFont.type) {
                case 'json': {
                    loader.load( targetFont.url, function ( response ) {
                        font = response;
                        refreshText();
                    });
                    break;
                }
                case 'woff':
                case 'ttf': {
                    function applyFont() {
                        console.time("convert font");
                        var json = convert(targetFont.parsedBuffer, controls.text);
                        console.timeEnd("convert font");
                        font = loader.parse(JSON.parse(json));
                        console.log(font);
                        refreshText();
                    }

                    if (targetFont.parsedBuffer) {
                        applyFont();
                    } else {
                        fetch(targetFont.url)
                            .then(function(response) {
                                return response.arrayBuffer();
                            })
                            .then(function(buffer) {
                                console.time("parse font");
                                targetFont.parsedBuffer = opentype.parse(buffer);
                                console.timeEnd("parse font");
                                if(targetFont.parsedBuffer.supported) {
                                    applyFont();
                                }
                            });
                    }
                    break;
                }
            }
        }

        function refreshText() {
            group.remove( textMesh );

            if ( ! controls.text ) return;

            createText();
        }

        function createText() {
            textGeo = new THREE.TextGeometry( controls.text, {
                font: font,
                size: controls.size,
                height: controls.depth,

                bevelThickness: bevelThickness,
                bevelSize: bevelSize,
                bevelEnabled: controls.bevelEnabled,
                bevelOffset: controls.bevelOffset,
                bevelSegments: controls.bevelSegments,

                curveSegments: curveSegments,
            });

            textGeo.computeBoundingBox();
            textGeo.computeVertexNormals();

            var centerOffsetX = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
            var centerOffsetY = - 0.5 * ( textGeo.boundingBox.max.y - textGeo.boundingBox.min.y );

            textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );
            textGeo.center();

            // MATERIAL
            var frontColor = controls.frontColor.substring(1);
            var sideColor = controls.sideColor.substring(1);

            var frontTexture = new THREE.TextureLoader().load('./lava.jpg');
            frontTexture.wrapS = frontTexture.wrapT = THREE.RepeatWrapping;
            frontTexture.repeat.set(0.05, 0.05);

            materials = [
                controls.frontTextureEnabled ? new THREE.MeshPhongMaterial( {
                    map: frontTexture,
                }) : new THREE.MeshPhongMaterial( {
                    color: parseInt(frontColor, 16),
                }), // front
                controls.sideTextureEnabled ? new THREE.MeshPhongMaterial( {
                    map: frontTexture,
                    side: THREE.DoubleSide,
                }) : new THREE.MeshPhongMaterial( {
                    color: parseInt(sideColor, 16),
                    side: THREE.DoubleSide,
                }), // side
            ];
            materials[0].opacity = controls.frontOpacity;
            materials[1].opacity = controls.sideOpacity

            textMesh = new THREE.Mesh( textGeo, materials );

            group.add( textMesh );
        }

        function onDocumentMouseDown( event ) {
            event.preventDefault();
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mouseout', onDocumentMouseOut, false );

            document.addEventListener( 'touchmove', onDocumentMouseMove, false );
            document.addEventListener( 'touchend', onDocumentMouseUp, false );

            mouseXOnMouseDown = event.touches ? event.touches[0].clientX : event.clientX - windowHalfX;
            mouseYOnMouseDown = event.touches ? event.touches[0].clientY : event.clientY - windowHalfY;
            targetRotationOnMouseDown = targetRotation;
            targetRotationXOnMouseDown = targetRotationX;

        }

        function onDocumentMouseMove( event ) {
            mouseX = event.touches ? event.touches[0].clientX : event.clientX - windowHalfX;
            mouseY = event.touches ? event.touches[0].clientY : event.clientY - windowHalfY;
            targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
            targetRotationX = targetRotationXOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.02;

        }

        function onDocumentMouseUp() {
            document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
            document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
            document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            document.removeEventListener( 'touchmove', onDocumentMouseMove, false );
            document.removeEventListener( 'touchend', onDocumentMouseUp, false );
        }

        function onDocumentMouseOut() {
            document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
            document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
            document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            document.removeEventListener( 'touchmove', onDocumentMouseMove, false );
            document.removeEventListener( 'touchend', onDocumentMouseUp, false );
        }

        function onWindowResize() {
            width = window.innerWidth,
            height = window.innerHeight,

            windowHalfX = width / 2;
            windowHalfY = height / 2;

            camera.left = width / - 2,
            camera.right = width / 2,
            camera.top = height / 2,
            camera.bottom = height / - 2,
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
            group.rotation.x += ( targetRotationX - group.rotation.x) * 0.05;

            camera.lookAt( cameraTarget );
            renderer.clear();
            renderer.render( scene, camera );
        }

        init();
        initGUI();
        animate();
    </script>
</body>
</html>