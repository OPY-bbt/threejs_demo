<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="https://unpkg.com/three@0.124.0/build/three.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
  <style>
    html,
    body {
      margin: 0;
      background-color: #040d21;
    }

    #container {
      width: 704px;
      height: 704px;
      overflow: hidden;
      position: relative;
    }

    svg {
      display: block;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>

<body>
  <div id="container">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" height="704"
      viewBox="0 0 704 704" width="704" class="js-webgl-globe-loading position-absolute left-0 right-0 top-0 bottom-0"
      style="margin: auto; transform: scale(0.8);">
      <filter id="a" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="560" width="560" x="70"
        y="70">
        <feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood>
        <feBlend in="SourceGraphic" in2="BackgroundImageFix" mode="normal" result="shape"></feBlend>
        <feColorMatrix in="SourceAlpha" result="hardAlpha" type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix>
        <feOffset dx="2" dy="2"></feOffset>
        <feGaussianBlur stdDeviation="7.5"></feGaussianBlur>
        <feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite>
        <feColorMatrix type="matrix" values="0 0 0 0 0.447059 0 0 0 0 0.643137 0 0 0 0 0.988235 0 0 0 0.49 0">
        </feColorMatrix>
        <feBlend in2="shape" mode="normal" result="effect1_innerShadow"></feBlend>
        <feColorMatrix in="SourceAlpha" result="hardAlpha" type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix>
        <feOffset dx="1" dy="1"></feOffset>
        <feGaussianBlur stdDeviation="3"></feGaussianBlur>
        <feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite>
        <feColorMatrix type="matrix" values="0 0 0 0 0.625 0 0 0 0 0.9325 0 0 0 0 1 0 0 0 0.32 0"></feColorMatrix>
        <feBlend in2="effect1_innerShadow" mode="normal" result="effect2_innerShadow"></feBlend>
        <feColorMatrix in="SourceAlpha" result="hardAlpha" type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix>
        <feOffset dx="-10" dy="-10"></feOffset>
        <feGaussianBlur stdDeviation="3"></feGaussianBlur>
        <feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite>
        <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"></feColorMatrix>
        <feBlend in2="effect2_innerShadow" mode="normal" result="effect3_innerShadow"></feBlend>
      </filter>
      <radialGradient id="b" cx="0" cy="0"
        gradientTransform="matrix(-199.20400108 -199.20400108 199.20400108 -199.20400108 332.08 338.37)"
        gradientUnits="userSpaceOnUse" r="1">
        <stop offset=".875" stop-color="#fff"></stop>
        <stop offset=".937507" stop-color="#3e68ff"></stop>
        <stop offset="1" stop-color="#03009f" stop-opacity="0"></stop>
      </radialGradient>
      <linearGradient id="c" gradientUnits="userSpaceOnUse" x1="352" x2="352" y1="331" y2="628">
        <stop offset="0" stop-color="#06060e"></stop>
        <stop offset="1" stop-color="#0f0e20"></stop>
      </linearGradient>
      <radialGradient id="d" cx="0" cy="0"
        gradientTransform="matrix(-5.99972278 523.99965313 -523.99965313 -5.99972278 170 147)"
        gradientUnits="userSpaceOnUse" r="1">
        <stop offset="0" stop-color="#4b60fb"></stop>
        <stop offset=".565687" stop-color="#33205d"></stop>
        <stop offset="1" stop-color="#33205d" stop-opacity="0"></stop>
      </radialGradient>
      <radialGradient id="e" cx="0" cy="0"
        gradientTransform="matrix(41.99992987 206.0000547 -206.0000547 41.99992987 292 327)"
        gradientUnits="userSpaceOnUse" r="1">
        <stop offset="0" stop-color="#354097"></stop>
        <stop offset="1" stop-color="#243273" stop-opacity="0"></stop>
      </radialGradient>
      <radialGradient id="f" cx="0" cy="0"
        gradientTransform="matrix(-84.00137423 185.99914213 -185.99914213 -84.00137423 462 399)"
        gradientUnits="userSpaceOnUse" r="1">
        <stop offset="0" stop-color="#040d20"></stop>
        <stop offset="1" stop-color="#040d20" stop-opacity="0"></stop>
      </radialGradient>
      <circle cx="352" cy="352" fill="url(#b)" r="303"
        transform="matrix(.98453041 .1752138 -.1752138 .98453041 67.120553 -56.22996)"></circle>
      <g filter="url(#a)">
        <circle cx="352" cy="352" fill="url(#c)" r="276"></circle>
        <circle cx="352" cy="352" fill="url(#d)" r="276"></circle>
        <circle cx="352" cy="352" fill="url(#e)" r="276"></circle>
        <circle cx="352" cy="352" fill="url(#f)" r="276"></circle>
      </g>
    </svg>
  </div>
  <script>
    const svg = document.querySelector("svg");
    const container = document.querySelector("#container");
    const fl = 16777215;
    const ml = 2197759;
    const gl = 16018366;
    const bl = {
      parentNode: container,
      isMobile: false,
      pixelRatio: window.devicePixelRatio,
    };
    const cl = 25;
    const Ml = Math.PI / 180;
    const wl = new THREE.Vector3;
    const Sl = 180 / Math.PI;

    const Yi = THREE.Group;
    const v = THREE.Vector3;
    const os = THREE.CircleBufferGeometry;
    const kt = THREE.MeshBasicMaterial;
    const ko = THREE.CubicBezierCurve3;
    const Ws = THREE.TubeBufferGeometry;
    const Le = THREE.Mesh;
    const Gs = THREE.RingBufferGeometry;

    // 欧拉角
    const hl = new THREE.Euler(0.3, 4.6, 0.05);

    // 时间相关
    class Ia {
      constructor(t) {
        (this.autoStart = void 0 === t || t),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      start() {
        (this.startTime = ("undefined" == typeof performance
          ? Date
          : performance
        ).now()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0);
      }
      stop() {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
      }
      getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
      }
      getDelta() {
        let t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          const e = ("undefined" == typeof performance
            ? Date
            : performance
          ).now();
          (t = (e - this.oldTime) / 1e3),
            (this.oldTime = e),
            (this.elapsedTime += t);
        }
        return t;
      }
    }

    // 球体
    class Xl {
      constructor(t) {
        (this.props = t), this.init();
      }
      init() {
        const {
          radius: t,
          detail: e = 50,
          renderer: n,
          shadowPoint: i,
          highlightPoint: r,
          highlightColor: s,
          frontHighlightColor: o = 3555965,
          waterColor: c = 857395,
          landColorFront: h = 16777215,
          shadowDist: u,
          highlightDist: d,
          frontPoint: f,
        } = this.props,
          m = new THREE.SphereBufferGeometry(t, e, e),
          y = new THREE.MeshStandardMaterial({
            color: c,
            metalness: 0,
            roughness: 0.9,
          });
        (this.uniforms = []),
          (y.onBeforeCompile = (t) => {
            (t.uniforms.shadowDist = {
              value: u,
            }),
              (t.uniforms.highlightDist = {
                value: d,
              }),
              (t.uniforms.shadowPoint = {
                value: new THREE.Vector3().copy(i),
              }),
              (t.uniforms.highlightPoint = {
                value: new THREE.Vector3().copy(r),
              }),
              (t.uniforms.frontPoint = {
                value: new THREE.Vector3().copy(f),
              }),
              (t.uniforms.highlightColor = {
                value: new THREE.Color(s),
              }),
              (t.uniforms.frontHighlightColor = {
                value: new THREE.Color(o),
              }),
              (t.vertexShader =
                "#define GLSLIFY 1\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvarying vec3 vWorldPosition;\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t// # include <worldpos_vertex>\n    vec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\tvWorldPosition = worldPosition.xyz;\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"),
              (t.fragmentShader =
                "#define GLSLIFY 1\n#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform float shadowDist;\nuniform float highlightDist;\nuniform vec3 shadowPoint;\nuniform vec3 highlightPoint;\nuniform vec3 frontPoint;\nuniform vec3 highlightColor;\nuniform vec3 frontHighlightColor;\n\nvarying vec3 vWorldPosition;\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_MAP\n\n\t\tvec4 texelColor = texture2D( map, vUv );\n\t\ttexelColor = mapTexelToLinear( texelColor );\n\t\t\n\t\t#ifndef IS_FILL\n\t\t\tdiffuseColor *= texelColor;\n\t\t#endif\n\n\t#endif\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\n    float dist;\n\tfloat distZ;\n\n    // highlights\n\t#ifdef USE_HIGHLIGHT\n\t\tdist = distance(vWorldPosition, highlightPoint);\n\t\tdistZ = distance(vWorldPosition.z, 0.0);\n\t\toutgoingLight = mix(highlightColor, outgoingLight, smoothstep(0.0, highlightDist, dist) * smoothstep(0.0, 3.0, pow(distZ, 0.5)));\n        outgoingLight = mix(outgoingLight * 2.0, outgoingLight, smoothstep(0.0, 12.0, distZ));\n\t#endif\n\n    // front hightlight\n    #ifdef USE_FRONT_HIGHLIGHT\n        dist = distance(vWorldPosition * vec3(0.875, 0.5, 1.0), frontPoint);\n        outgoingLight = mix(frontHighlightColor * 1.6, outgoingLight, smoothstep(0.0, 15.0, dist));\n    #endif\n\n    // shadows\n    dist = distance(vWorldPosition, shadowPoint);\n\toutgoingLight = mix(outgoingLight * 0.01, outgoingLight, smoothstep(0.0, shadowDist, dist));\n    // shadow debug\n\t// outgoingLight = mix(vec3(1.0, 0.0, 0.0), outgoingLight, smoothstep(0.0, shadowDist, dist));\n\n\t#ifdef IS_FILL\n\t\toutgoingLight = mix(outgoingLight, outgoingLight * 0.5, 1.0 - texelColor.g * 1.5);\n\t#endif\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"),
              this.uniforms.push(t.uniforms);
          }),
          (y.defines = {
            USE_HIGHLIGHT: 1,
            USE_HIGHLIGHT_ALT: 1,
            USE_FRONT_HIGHLIGHT: 1,
            DITHERING: 1,
          }),
          (this.mesh = new THREE.Group());
        const x = new THREE.Mesh(m, y);
        (x.renderOrder = 1),
          this.mesh.add(x),
          (this.meshFill = x),
          (this.materials = [y]);
      }
      setShadowPoint(t) {
        this.uniforms &&
          this.uniforms.forEach((e) => {
            e.shadowPoint.value.copy(t);
          });
      }
      setHighlightPoint(t) {
        this.uniforms &&
          this.uniforms.forEach((e) => {
            e.highlightPoint.value.copy(t);
          });
      }
      setFrontPoint(t) {
        this.uniforms &&
          this.uniforms.forEach((e) => {
            e.frontPoint.value.copy(t);
          });
      }
      setShadowDist(t) {
        this.uniforms &&
          this.uniforms.forEach((e) => {
            e.shadowDist.value = t;
          });
      }
      setHighlightDist(t) {
        this.uniforms &&
          this.uniforms.forEach((e) => {
            e.highlightDist.value = t;
          });
      }
      dispose() {
        (this.mesh = null),
          (this.materials = null),
          (this.uniforms = null),
          (this.meshFill = null);
      }
    }

    class Globe {
      constructor() {
        this.update = this.update.bind(this);

        this.initBase();
        this.initScene();
      }
      initBase() {
        const { width: w, height: h } = container.getBoundingClientRect();
        this.scene = new THREE.Scene();
        (this.camera = new THREE.PerspectiveCamera(20, w / h, 170, 260)),
          (this.renderer = new THREE.WebGLRenderer({
            powerPreference: "high-performance",
            alpha: !1,
            preserveDrawingBuffer: !1,
          })),
          (this.then = Date.now() / 1e3),
          (this.fpsWarnings = 0),
          (this.fpsWarningThreshold = 50),
          (this.fpsTarget = 60),
          (this.fpsEmergencyThreshold = 12),
          (this.fpsTargetSensitivity = 0.925),
          (this.fpsStorage = []),
          (this.worldDotRows = 200),
          (this.worldDotSize = 0.095),
          (this.renderQuality = 4),
          this.renderer.setPixelRatio(window.devicePixelRatio || 1),
          this.renderer.setSize(w, h),
          this.renderer.setClearColor(265505, 1),
          container.appendChild(this.renderer.domElement),
          this.renderer.domElement.classList.add("webgl-canvas"),
          this.renderer.domElement.classList.add("js-globe-canvas");

        // 平行光
        const i = new THREE.AmbientLight(16777215, 0.8);
        this.scene.add(i);

        (this.parentContainer = new THREE.Group()),
          (this.parentContainer.name = "parentContainer");
        let r = hl;
        const s = new Date().getTimezoneOffset() || 0;
        (r.y = hl.y + Math.PI * (s / 720)),
          this.parentContainer.rotation.copy(r),
          this.scene.add(this.parentContainer);

        // 光环
        (this.haloContainer = new THREE.Group());
        (this.haloContainer.name = "haloContainer");
        this.scene.add(this.haloContainer);

        (this.container = new THREE.Group()),
          (this.container.name = "container"),
          this.parentContainer.add(this.container);

        this.camera.position.set(0, 0, 220),
          this.scene.add(this.camera),
          (this.clock = new Ia()),
          (this.mouse = new THREE.Vector3(0, 0, 0.5)),
          (this.mouseScreenPos = new THREE.Vector2(-9999, -9999)),
          // 光射投影用于计算出鼠标移过什么物体。
          (this.raycaster = new THREE.Raycaster()),
          (this.raycaster.far = 260),
          (this.paused = !1),
          (this.canvasOffset = {
            x: 0,
            y: 0,
          }),
          this.updateCanvasOffset(),
          (this.highlightMaterial = new THREE.MeshBasicMaterial({
            opacity: 1,
            transparent: !1,
            color: fl,
          })),
          // this.handleResize(),
          this.startUpdating();
      }

      initScene() {
        // const {isMobile: t, globeRadius: e=cl, assets: {textures: {globeDiffuse: n, globeAlpha: i}}} = bl;
        const t = false;
        const e = 25;
        const n = undefined;
        const i = undefined;

        (this.radius = e),
          (this.light0 = new THREE.SpotLight(ml, 12, 120, 0.3, 0, 1.1)),
          (this.light1 = new THREE.DirectionalLight(11124735, 3)),
          (this.light3 = new THREE.SpotLight(gl, 5, 75, 0.5, 0, 1.25)),
          (this.light0.target = this.parentContainer),
          (this.light1.target = this.parentContainer),
          (this.light3.target = this.parentContainer),
          this.scene.add(this.light0, this.light1, this.light3),
          this.positionContainer(),
          (this.shadowPoint = new THREE.Vector3()
            .copy(this.parentContainer.position)
            .add(
              new THREE.Vector3(
                0.7 * this.radius,
                0.3 * -this.radius,
                this.radius
              )
            ));
        (this.highlightPoint = new THREE.Vector3()
          .copy(this.parentContainer.position)
          .add(
            new THREE.Vector3(1.5 * -this.radius, 1.5 * -this.radius, 0)
          )),
          (this.frontPoint = new THREE.Vector3()
            .copy(this.parentContainer.position)
            .add(new THREE.Vector3(0, 0, this.radius)));

        // 增加地球
        const r = new Xl({
          radius: this.radius,
          detail: 55,
          renderer: this.renderer,
          shadowPoint: this.shadowPoint,
          shadowDist: 1.5 * this.radius,
          highlightPoint: this.highlightPoint,
          highlightColor: 5339494,
          highlightDist: 5,
          frontPoint: this.frontPoint,
          frontHighlightColor: 2569853,
          waterColor: 1513012,
          landColorFront: fl,
          landColorBack: fl,
        });
        this.container.add(r.mesh), (this.globe = r);

        // 增加光环
        const s = new THREE.Mesh(new THREE.SphereBufferGeometry(cl, 45, 45), new THREE.ShaderMaterial({
          uniforms: {
            c: {
              type: "f",
              value: .7
            },
            p: {
              type: "f",
              value: 15
            },
            glowColor: {
              type: "c",
              value: new THREE.Color(1844322)
            },
            viewVector: {
              type: "v3",
              value: new THREE.Vector3(0, 0, 220)
            }
          },
          vertexShader: "#define GLSLIFY 1\nuniform vec3 viewVector;\nuniform float c;\nuniform float p;\nvarying float intensity;\nvoid main() \n{\n  vec3 vNormal = normalize( normalMatrix * normal );\n  vec3 vNormel = normalize( normalMatrix * viewVector );\n  intensity = pow( c - dot(vNormal, vNormel), p );\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
          fragmentShader: "#define GLSLIFY 1\nuniform vec3 glowColor;\nvarying float intensity;\nvoid main() \n{\n\tvec3 glow = glowColor * intensity;\n  gl_FragColor = vec4( glow, 1.0 );\n}",
          side: 1,
          blending: 2,
          transparent: !0
        }));
        s.scale.multiplyScalar(1.15),
          s.rotateX(.03 * Math.PI),
          s.rotateY(.03 * Math.PI),
          s.renderOrder = 3,
          this.haloContainer.add(s),
          this.dragging = !1,
          this.rotationSpeed = .05,
          this.raycastIndex = 0,
          this.raycastTrigger = 10,
          this.raycastTargets = [],
          this.intersectTests = [];

        this.controls = new Ql({
          object: this.container,
          objectContainer: this.parentContainer,
          domElement: this.renderer.domElement,
          setDraggingCallback: this.setDragging,
          rotateSpeed: t ? 1.5 : 3,
          autoRotationSpeed: this.rotationSpeed,
          easing: .12,
          maxRotationX: .5,
          camera: this.camera
        })
      }

      positionContainer() {
        const { isMobile: t, parentNode: e } = bl,
          { height: n } = e.getBoundingClientRect(),
          i = (850 / n) * 1;
        (this.containerScale = i),
          t
            ? this.parentContainer.position.set(0, 0, 0)
            : (this.parentContainer.scale.set(i, i, i),
              this.parentContainer.position.set(0, 0, 0),
              this.haloContainer.scale.set(i, i, i)),
          this.haloContainer.position.set(0, 0, -10),
          this.positionLights(i);
      }

      positionLights(t = 1) {
        this.light0 &&
          (this.light0.position
            .set(this.parentContainer.position.x - 2.5 * this.radius, 80, -40)
            .multiplyScalar(t),
            (this.light0.distance = 120 * t)),
          this.light1 &&
          this.light1.position
            .set(
              this.parentContainer.position.x - 50,
              this.parentContainer.position.y + 30,
              10
            )
            .multiplyScalar(t),
          this.light2 &&
          (this.light2.position
            .set(this.parentContainer.position.x - 25, 0, 100)
            .multiplyScalar(t),
            (this.light2.distance = 150 * t)),
          this.light3 &&
          (this.light3.position
            .set(
              this.parentContainer.position.x + this.radius,
              this.radius,
              2 * this.radius
            )
            .multiplyScalar(t),
            (this.light3.distance = 75 * t));
      }

      startUpdating() {
        this.stopUpdating(), this.update();
      }

      stopUpdating() {
        cancelAnimationFrame(this.rafID);
      }

      update() {
        this.handleUpdate(),
          this.hasLoaded || this.sceneDidLoad(),
          (this.rafID = requestAnimationFrame(this.update));
      }

      sceneDidLoad() {
        // svg 替换成 canvas
        this.hasLoaded = !0;
        const t = document.querySelector(".js-webgl-globe-loading");
        if (!t) return;
        const e = {
          fill: "both",
          duration: 600,
          easing: "ease",
        };
        this.renderer.domElement.animate(
          [
            {
              opacity: 0,
              transform: "scale(0.8)",
            },
            {
              opacity: 1,
              transform: "scale(1)",
            },
          ],
          e
        ),
          t
            .animate(
              [
                {
                  opacity: 1,
                  transform: "scale(0.8)",
                },
                {
                  opacity: 0,
                  transform: "scale(1)",
                },
              ],
              e
            )
            .addEventListener("finish", () => {
              t.remove();
            });
      }

      handleUpdate() {
        // if (this.monitorFps(),
        // null === this.clock)
        //     return;
        const t = this.clock.getDelta();
        if (this.controls && this.controls.update(t),
          this.visibleIndex += t * this.indexIncrementSpeed,
          this.visibleIndex >= this.maxAmount - 60 && (this.visibleIndex = 60),
          this.openPrEntity && this.openPrEntity.update(this.visibleIndex),
          this.mergedPrEntity && this.mergedPrEntity.update(t, this.visibleIndex),
          !this.dataInfo)
          return void this.render();
        // const {raycaster: e, camera: n, mouseScreenPos: i} = this;
        // let r, s = !1;
        // if (this.raycastIndex % this.raycastTrigger == 0) {
        //     if (this.testForDataIntersection(),
        //     this.intersects.length) {
        //         this.radius,
        //         this.containerScale;
        //         for (let t = 0; t < this.intersects.length && !s; t++) {
        //             const {instanceId: e, object: n} = this.intersects[t];
        //             if ("lineMesh" === n.name) {
        //                 r = this.setMergedPrEntityDataItem(n),
        //                 s = !0;
        //                 break
        //             }
        //             if (n === this.openPrEntity.spikeIntersects && this.shouldShowOpenPrEntity(e)) {
        //                 r = this.setOpenPrEntityDataItem(e),
        //                 s = !0;
        //                 break
        //             }
        //             if ("arcticCodeVault" === n.name) {
        //                 r = {
        //                     header: "Arctic Code Vault",
        //                     body: "Svalbard • Cold storage of the work of 3,466,573 open source developers. For safe keeping.\nLearn more →",
        //                     type: pl,
        //                     url: "https://archiveprogram.github.com"
        //                 },
        //                 this.highlightArcticCodeVault(),
        //                 s = !0;
        //                 break
        //             }
        //         }
        //     }
        //     s && r ? (this.setDataInfo(r),
        //     this.dataInfo.show()) : (this.dataInfo.hide(),
        //     this.openPrEntity.setHighlightIndex(-9999),
        //     this.mergedPrEntity.resetHighlight(),
        //     this.resetArcticCodeVaultHighlight(),
        //     this.dataItem = null,
        //     bl.isMobile && (this.mouse = {
        //         x: -9999,
        //         y: -9999
        //     }))
        // }
        // this.dragging && (this.dataInfo.hide(),
        // this.openPrEntity.setHighlightIndex(-9999),
        // this.mergedPrEntity.resetHighlight(),
        // this.resetArcticCodeVaultHighlight()),
        // this.dataInfo.isVisible && this.dataInfo.update(i, this.canvasOffset),
        // this.raycastIndex++,
        // this.raycastIndex >= this.raycastTrigger && (this.raycastIndex = 0),
        this.render();
      }

      render() {
        this.renderer.render(this.scene, this.camera);
      }

      updateCanvasOffset() {
        // const t = document.querySelector(".js-webgl-globe-data").getBoundingClientRect()
        //   , e = document.querySelector(".js-webgl-globe").getBoundingClientRect();
        // this.canvasOffset = {
        //     x: e.x - t.x,
        //     y: e.y - t.y
        // }
      }

      initDataObjects(t) {
        const e = {
          openPrColor: ml,
          openPrParticleColor: 6137337,
          mergedPrColor: gl,
          mergedPrColorHighlight: fl
        };
        this.buildWorldGeometry();

        // github位于北极的仓库旗子
        this.addArcticCodeVault();

        this.maxAmount = t.length,
          this.maxIndexDistance = 60,
          this.indexIncrementSpeed = 15,
          this.visibleIndex = 60,
          // 环形外层大量白点
          this.openPrEntity = new Kl({
            data: t,
            maxAmount: this.maxAmount,
            radius: this.radius,
            camera: this.camera,
            maxIndexDistance: this.maxIndexDistance,
            indexIncrementSpeed: this.indexIncrementSpeed,
            visibleIndex: this.visibleIndex,
            colors: e
          });

        // 管状动画
        this.mergedPrEntity = new $l({
          data: t,
          maxAmount: this.maxAmount,
          radius: this.radius,
          camera: this.camera,
          maxIndexDistance: this.maxIndexDistance,
          visibleIndex: this.visibleIndex,
          colors: e,
          mouse: this.mouse
        });
        // const {width: n, height: i} = bl.parentNode.getBoundingClientRect()
        //   , r = 850 / i * 1;
        // this.containerScale = r,
        // this.dataInfo = new ec({
        //     parentSelector: ".js-webgl-globe-data",
        //     domElement: this.renderer.domElement,
        //     controls: this.controls
        // }),
        this.dataItem = {},
          this.intersectTests.push(this.globe.meshFill),
          this.intersectTests.push(this.openPrEntity.spikeIntersects);
        this.intersectTests.push(...this.mergedPrEntity.lineHitMeshes),
          this.intersects = [];
      }

      transitionIn() {
        return new Promise((() => {
          this.container.add(this.openPrEntity.mesh);
          this.container.add(this.mergedPrEntity.mesh)
        }
        ))
      }

      addArcticCodeVault() {
        new THREE.CylinderBufferGeometry(.075, .075, 1.5, 8),
          this.vaultMaterial = new THREE.MeshBasicMaterial({
            blending: 2,
            opacity: .9,
            transparent: !0,
            color: 4299263
          }),
          this.vaultIsHighlighted = !1;
        const t = Rl(78.14, 15.26, this.radius)
          , e = Rl(78.14, 15.26, this.radius + 5)
          , { basePath: n, imagePath: i } = bl
          , r = `./flag.obj`;
        (new THREE.OBJLoader).load(r, (n => {
          n.position.set(t.x, t.y, t.z),
            n.lookAt(e.x, e.y, e.z),
            n.rotateX(90 * Ml),
            n.scale.set(.1, .1, .1),
            n.renderOrder = 3;
          for (const t of n.children)
            t.material = this.vaultMaterial,
              t.name = "arcticCodeVault",
              this.arcticCodeVaultMesh = t,
              this.intersectTests.push(this.arcticCodeVaultMesh);
          this.container.add(n)
        }
        ))
      }

      visibilityForCoordinate(t, e, n) {
        const i = 4 * n.width
          , r = parseInt((t + 180) / 360 * n.width + .5)
          , s = n.height - parseInt((e + 90) / 180 * n.height - .5)
          , o = parseInt(i * (s - 1) + 4 * r) + 3;
        return n.data[o] > 90
      }

      buildWorldGeometry() {
        // 根据颜色渲染陆地和海洋
        const { assets: { textures: { worldMap: t } } } = bl
          , e = new THREE.Object3D
          , n = this.getImageData(t.image)
          , i = []
          , r = this.worldDotRows;
        for (let h = -90; h <= 90; h += 180 / r) {
          const t = Math.cos(Math.abs(h) * Ml) * cl * Math.PI * 2 * 2;
          for (let r = 0; r < t; r++) {
            const s = 360 * r / t - 180;
            if (!this.visibilityForCoordinate(s, h, n))
              continue;
            const o = Rl(h, s, this.radius);
            e.position.set(o.x, o.y, o.z);
            const c = Rl(h, s, this.radius + 5);
            e.lookAt(c.x, c.y, c.z),
              e.updateMatrix(),
              i.push(e.matrix.clone())
          }
        }
        const s = new THREE.CircleBufferGeometry(this.worldDotSize, 5)
          , o = new THREE.MeshStandardMaterial({
            color: 3818644,
            metalness: 0,
            roughness: .9,
            transparent: !0,
            alphaTest: .02
          });
        o.onBeforeCompile = function (t) {
          t.fragmentShader = t.fragmentShader.replace("gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "\n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n        if (gl_FragCoord.z > 0.51) {\n          gl_FragColor.a = 1.0 + ( 0.51 - gl_FragCoord.z ) * 17.0;\n        }\n      ")
        }
          ;
        const c = new THREE.InstancedMesh(s, o, i.length);
        for (let h = 0; h < i.length; h++)
          c.setMatrixAt(h, i[h]);
        c.renderOrder = 3,
          this.worldMesh = c,
          this.container.add(c)
      }

      getImageData(t) {
        const e = document.createElement("canvas").getContext("2d");
        return e.canvas.width = t.width,
          e.canvas.height = t.height,
          e.drawImage(t, 0, 0, t.width, t.height),
          e.getImageData(0, 0, t.width, t.height)
      }
    }

    function Nl(t, e, n) {
      return Math.max(e, Math.min(t, n))
    }

    function Al(t, e, n) {
      const i = n || new THREE.Matrix4;
      i.identity(),
        i.makeRotationY(e),
        i.multiply(t.matrix),
        t.matrix.copy(i),
        t.rotation.setFromRotationMatrix(t.matrix)
    }

    function Rl(t, e, n, i) {
      i = i || new THREE.Vector3;
      const r = (90 - t) * Ml
        , s = (e + 180) * Ml;
      return i.set(-n * Math.sin(r) * Math.cos(s), n * Math.cos(r), n * Math.sin(r) * Math.sin(s)),
        i
    }

    function Dl(t, e, n, i, r) {
      return function (t, e, n) {
        return (n - e) * t + e
      }(function (t, e, n) {
        return (t - e) / (n - e) || 0
      }(t, e, n), i, r)
    }

    function El(t) {
      return t * Ml
    }

    function Tl(t) {
      return t * Sl
    }

    function Cl(t, e, n, i) {
      t = El(t),
        e = El(e),
        n = El(n);
      const r = (i = El(i)) - e
        , s = Math.cos(n) * Math.cos(r)
        , o = Math.cos(n) * Math.sin(r)
        , c = Math.atan2(Math.sin(t) + Math.sin(n), Math.sqrt((Math.cos(t) + s) * (Math.cos(t) + s) + o * o))
        , h = e + Math.atan2(o, Math.cos(t) + s);
      return [Tl(c), Tl(h)]
    }

    function Ll(t) {
      t instanceof THREE.Mesh && (t.geometry && t.geometry.dispose(),
        t.material && (t.material.map && t.material.map.dispose(),
          t.material.lightMap && t.material.lightMap.dispose(),
          t.material.bumpMap && t.material.bumpMap.dispose(),
          t.material.normalMap && t.material.normalMap.dispose(),
          t.material.specularMap && t.material.specularMap.dispose(),
          t.material.envMap && t.material.envMap.dispose(),
          t.material.emissiveMap && t.material.emissiveMap.dispose(),
          t.material.metalnessMap && t.material.metalnessMap.dispose(),
          t.material.roughnessMap && t.material.roughnessMap.dispose(),
          t.material.dispose()))
    }

    class $l {
      constructor(t) {
        this.props = t,
          this.init()
      }
      init() {
        const { data: t, radius: e = 1, camera: n, maxAmount: i = t.length, maxIndexDistance: r, visibleIndex: s, colors: o } = this.props
          , { parentNode: c, lineWidth: h, pixelRatio: u } = bl;
        this.mesh = new THREE.Group,
          this.isAnimating = [],
          this.animatingLandingsOut = [],
          this.landings = [],
          this.lineMeshes = [],
          this.lineHitMeshes = [],
          this.highlightedMesh,
          this.colors = o,
          this.landingGeo = new THREE.CircleBufferGeometry(.35, 8),
          this.TUBE_RADIUS_SEGMENTS = 3,
          this.HIT_DETAIL_FRACTION = 4,
          this.DATA_INCREMENT_SPEED = 1.5,
          this.PAUSE_LENGTH_FACTOR = 2,
          this.MIN_PAUSE = 3e3,
          this.visibleIndex = 0,
          this.lineAnimationSpeed = 600;
        const d = new THREE.Vector3
          , f = new THREE.Vector3;
        this.tubeMaterial = new THREE.MeshBasicMaterial({
          blending: 2,
          opacity: .95,
          transparent: !0,
          color: this.colors.mergedPrColor
        }),
          this.highlightMaterial = new THREE.MeshBasicMaterial({
            opacity: 1,
            transparent: !1,
            color: this.colors.mergedPrColorHighlight
          }),
          this.hiddenMaterial = new THREE.MeshBasicMaterial({
            visible: !1
          });
        for (let x = 0; x < i; x++) {
          const { gop: n, gm: i } = t[x]
            , r = n
            , s = i
            , o = Rl(r.lat, r.lon, e)
            , c = Rl(s.lat, s.lon, e)
            , h = o.distanceTo(c);
          if (h > 1.5) {
            let t;
            t = Dl(h, 0, 2 * e, 1, h > 1.85 * e ? 3.25 : h > 1.4 * e ? 2.3 : 1.5);
            const n = Cl(r.lat, r.lon, s.lat, s.lon)
              , i = Rl(n[0], n[1], e * t);
            d.copy(i),
              f.copy(i);
            const u = Dl(h, 10, 30, .2, .15)
              , m = Dl(h, 10, 30, .8, .85);
            t = Dl(h, 0, 2 * e, 1, 1.7);
            const y = new THREE.CubicBezierCurve3(o, d, f, c);
            y.getPoint(u, d),
              y.getPoint(m, f),
              d.multiplyScalar(t),
              f.multiplyScalar(t);
            const b = new THREE.CubicBezierCurve3(o, d, f, c)
              , w = Rl(s.lat, s.lon, e + x / 1e4)
              , M = Rl(s.lat, s.lon, e + 5);
            this.landings.push({
              pos: w,
              lookAt: M
            });
            const S = 20 + parseInt(b.getLength())
              , E = new THREE.TubeBufferGeometry(b, S, .08, this.TUBE_RADIUS_SEGMENTS, !1)
              , T = new THREE.TubeBufferGeometry(b, parseInt(S / this.HIT_DETAIL_FRACTION), .6, this.TUBE_RADIUS_SEGMENTS, !1);
            E.setDrawRange(0, 0),
              T.setDrawRange(0, 0);
            const A = new THREE.Mesh(E, this.tubeMaterial)
              , L = new THREE.Mesh(T, this.hiddenMaterial);
            L.name = "lineMesh",
              A.userData = {
                dataIndex: x
              },
              L.userData = {
                dataIndex: x,
                lineMeshIndex: this.lineMeshes.length
              },
              this.lineMeshes.push(A),
              this.lineHitMeshes.push(L)
          }
        }
        const { width: m, height: y } = c.getBoundingClientRect()
      }
      resetHighlight() {
        null != this.highlightedMesh && (this.highlightedMesh.material = this.tubeMaterial,
          this.highlightedMesh = null)
      }
      setHighlightObject(t) {
        const e = parseInt(t.userData.lineMeshIndex)
          , n = this.lineMeshes[e];
        n != this.highlightedMesh && (n.material = this.highlightMaterial,
          this.resetHighlight(),
          this.highlightedMesh = n)
      }
      update(t = .01, e) {
        let n = parseInt(this.visibleIndex + t * this.DATA_INCREMENT_SPEED);
        n >= this.lineMeshes.length && (n = 0,
          this.visibleIndex = 0),
          n > this.visibleIndex && this.isAnimating.push(this.animatedObjectForIndex(n));
        let i = []
          , r = [];
        for (const s of this.isAnimating) {
          const e = s.line.geometry.index.count
            , n = s.line.geometry.drawRange.count + t * this.lineAnimationSpeed;
          let r = s.line.geometry.drawRange.start + t * this.lineAnimationSpeed;
          if (n >= e && r < e && this.animateLandingIn(s),
            n >= e * this.PAUSE_LENGTH_FACTOR + this.MIN_PAUSE && r < e) {
            if (s.line == this.highlightedMesh) {
              i.push(s);
              continue
            }
            r = this.TUBE_RADIUS_SEGMENTS * Math.ceil(r / this.TUBE_RADIUS_SEGMENTS);
            const t = this.TUBE_RADIUS_SEGMENTS * Math.ceil(r / this.HIT_DETAIL_FRACTION / this.TUBE_RADIUS_SEGMENTS);
            s.line.geometry.setDrawRange(r, n),
              s.lineHit.geometry.setDrawRange(t, n / this.HIT_DETAIL_FRACTION),
              i.push(s)
          } else
            r < e ? (s.line.geometry.setDrawRange(0, n),
              s.lineHit.geometry.setDrawRange(0, n / this.HIT_DETAIL_FRACTION),
              i.push(s)) : this.endAnimation(s)
        }
        for (let s = 0; s < this.animatingLandingsOut.length; s++)
          this.animateLandingOut(this.animatingLandingsOut[s]) && r.push(this.animatingLandingsOut[s]);
        this.isAnimating = i,
          this.animatingLandingsOut = r,
          this.visibleIndex = this.visibleIndex + t * this.DATA_INCREMENT_SPEED
      }
      endAnimation(t) {
        t.line.geometry.setDrawRange(0, 0),
          t.lineHit.geometry.setDrawRange(0, 0),
          this.mesh.remove(t.line),
          this.mesh.remove(t.lineHit),
          t.line = null,
          t.lineHit = null,
          this.animatingLandingsOut.push(t)
      }
      animateLandingIn(t) {
        if (t.dot.scale.x > .99) {
          if (null == t.dotFade)
            return;
          return t.dotFade.material.opacity = 0,
            this.mesh.remove(t.dotFade),
            Ll(t.dotFade),
            void (t.dotFade = null)
        }
        const e = t.dot.scale.x + .06 * (1 - t.dot.scale.x);
        t.dot.scale.set(e, e, 1);
        const n = t.dotFade.scale.x + .06 * (1 - t.dotFade.scale.x);
        t.dotFade.scale.set(n, n, 1),
          t.dotFade.material.opacity = 1 - n
      }
      animateLandingOut(t) {
        if (t.dot.scale.x < .01)
          return this.mesh.remove(t.dot),
            t.dot = null,
            Ll(t.dot),
            null != t.dotFade && (this.mesh.remove(t.dotFade),
              Ll(t.dotFade),
              t.dotFade = null),
            !1;
        const e = t.dot.scale.x - .15 * t.dot.scale.x;
        return t.dot.scale.set(e, e, 1),
          !0
      }
      animatedObjectForIndex(t) {
        const e = this.lineMeshes[t];
        this.mesh.add(e);
        const n = this.lineHitMeshes[t];
        this.mesh.add(n);
        const i = this.landingFromPositionData(this.landings[t]);
        this.mesh.add(i);
        const r = this.fadingLandingMeshFromMesh(i);
        return this.mesh.add(r),
        {
          line: e,
          lineHit: n,
          dot: i,
          dotFade: r
        }
      }
      landingFromPositionData(t) {
        const e = new Le(this.landingGeo, this.tubeMaterial);
        return e.position.set(t.pos.x, t.pos.y, t.pos.z),
          e.lookAt(t.lookAt.x, t.lookAt.y, t.lookAt.z),
          e.scale.set(0, 0, 1),
          e
      }
      fadingLandingMeshFromMesh(t) {
        const e = t.clone();
        return e.geometry = new THREE.RingBufferGeometry(1.55, 1.8, 16),
          e.material = new kt({
            color: this.colors.mergedPrColor,
            blending: 2,
            transparent: !0,
            opacity: 0,
            alphaTest: .02,
            visible: !0
          }),
          e.scale.set(0, 0, 1),
          e.renderOrder = 5,
          e
      }
      dispose() {
        this.mesh && Pl(this.mesh, Ll),
          this.mesh && this.mesh.parent && this.mesh.parent.remove(this.mesh),
          this.mesh = null
      }
    }

    class Ql {
      constructor(t) {
        this.props = t,
          this.handleMouseDown = this.handleMouseDown.bind(this),
          this.handleMouseMove = this.handleMouseMove.bind(this),
          this.handleMouseUp = this.handleMouseUp.bind(this),
          this.handleMouseOut = this.handleMouseOut.bind(this),
          this.handleTouchStart = this.handleTouchStart.bind(this),
          this.handleTouchMove = this.handleTouchMove.bind(this),
          this.handleTouchEnd = this.handleTouchEnd.bind(this),
          this.handlePause = this.handlePause.bind(this),
          this.handleResume = this.handleResume.bind(this),
          this.init()
      }
      init() {
        this.dragging = !1,
          this.mouse = new THREE.Vector2(.5, .5),
          this.lastMouse = new THREE.Vector2(.5, .5),
          this.target = new THREE.Vector3(0, 0),
          this.matrix = new THREE.Matrix4,
          this.velocity = new THREE.Vector2,
          this.autoRotationSpeedScalar = 1,
          this.autoRotationSpeedScalarTarget = 1,
          this.addListeners();
        // _l.on(vl, this.handlePause),
        // _l.on(yl, this.handleResume)
      }
      addListeners() {
        const { domElement: t } = this.props;
        this.removeListeners(),
          t.addEventListener("mousedown", this.handleMouseDown, !1),
          t.addEventListener("mousemove", this.handleMouseMove, !1),
          t.addEventListener("mouseup", this.handleMouseUp, !1),
          t.addEventListener("mouseout", this.handleMouseOut, !1),
          t.addEventListener("mouseleave", this.handleMouseOut, !1),
          t.addEventListener("touchstart", this.handleTouchStart, !1),
          t.addEventListener("touchmove", this.handleTouchMove, !1),
          t.addEventListener("touchend", this.handleTouchEnd, !1),
          t.addEventListener("touchcancel", this.handleTouchEnd, !1)
      }
      removeListeners() {
        const { domElement: t } = this.props;
        t.removeEventListener("mousedown", this.handleMouseDown),
          t.removeEventListener("mousemove", this.handleMouseMove),
          t.removeEventListener("mouseup", this.handleMouseUp),
          t.removeEventListener("mouseout", this.handleMouseOut),
          t.removeEventListener("mouseleave", this.handleMouseOut),
          t.removeEventListener("touchstart", this.handleTouchStart),
          t.removeEventListener("touchmove", this.handleTouchMove),
          t.removeEventListener("touchend", this.handleTouchEnd),
          t.removeEventListener("touchcancel", this.handleTouchEnd)
      }
      setMouse(t) {
        const { width: e, height: n } = bl.parentNode.getBoundingClientRect();
        this.mouse.x = t.clientX / e * 2 - 1,
          this.mouse.y = -t.clientY / n * 2 + 1
      }
      setDragging(t) {
        this.dragging = t;
        const { setDraggingCallback: e } = this.props;
        e && "function" == typeof e && e(t)
      }
      handlePause() {
        this.removeListeners()
      }
      handleResume() {
        this.addListeners()
      }
      handleMouseDown(t) {
        this.setMouse(t),
          this.setDragging(!0)
      }
      handleMouseMove(t) {
        this.setMouse(t)
      }
      handleMouseUp(t) {
        this.setMouse(t),
          this.setDragging(!1)
      }
      handleMouseOut() {
        this.setDragging(!1)
      }
      handleTouchStart(t) {
        this.setMouse(t.changedTouches[0]),
          this.lastMouse.copy(this.mouse),
          this.setDragging(!0)
      }
      handleTouchMove(t) {
        this.setMouse(t.changedTouches[0])
      }
      handleTouchEnd(t) {
        this.setMouse(t.changedTouches[0]),
          this.setDragging(!1)
      }
      update(t = .01) {
        let e = 0
          , n = 0;
        const { object: i, objectContainer: r, rotateSpeed: s, autoRotationSpeed: o, easing: c = .1, maxRotationX: h = .3 } = this.props;
        this.dragging && (e = this.mouse.x - this.lastMouse.x,
          n = this.mouse.y - this.lastMouse.y,
          this.target.y = Nl(this.target.y - n, -h, .6 * h)),
          r.rotation.x += (this.target.y + hl.x - r.rotation.x) * c,
          this.target.x += (e - this.target.x) * c,
          Al(i, this.target.x * s, this.matrix),
          this.dragging || Al(i, t * o * this.autoRotationSpeedScalar, this.matrix),
          this.autoRotationSpeedScalar += .05 * (this.autoRotationSpeedScalarTarget - this.autoRotationSpeedScalar),
          this.lastMouse.copy(this.mouse),
          this.velocity.set(e, n)
      }
      dispose() {
        this.removeListeners(),
          // _l.off(vl, this.handlePause),
          // _l.off(yl, this.handleResume),
          this.dragging = null,
          this.mouse = null,
          this.lastMouse = null,
          this.target = null,
          this.matrix = null,
          this.velocity = null,
          this.autoRotationSpeedScalar = null,
          this.autoRotationSpeedScalarTarget = null
      }
    }

    const loader = new THREE.TextureLoader();
    loader.load(
      // resource URL
      './map.png',

      // onLoad callback
      function (texture) {
        bl.assets = {
          textures: {
            worldMap: texture
          }
        }
        fetch('./data.json').then(response => response.json()).then((json) => {
          bl.data = filterData(json);
          const globe = new Globe();
          globe.initDataObjects(bl.data);
          globe.transitionIn(1.5, .6);
        })
      },

      // onProgress callback currently not supported
      undefined,

      // onError callback
      function () {
        console.error('An error happened.');
      }
    );

    function filterData(t) {
      const e = [];
      for (let r = 0; r < t.length; r++) {
        const n = t[r]
          , i = n.gop
          , s = n.gm;
        (i || s) && (n.gop = i || s,
          n.gm = s || i,
          n.uol = n.uol || n.uml,
          n.uml = n.uml || n.uol,
          n.gop.lat && n.gop.lon && n.gm.lat && n.gm.lon && (n.oa || n.ma) && e.splice(Math.floor(Math.random() * e.length), 0, n))
      }
      const n = e.slice(e.length - 60, e.length)
        , i = e.slice(0, 60);
      return n.concat(e, i)
    }

    function Dl(t, e, n, i, r) {
      return function (t, e, n) {
        return (n - e) * t + e
      }(function (t, e, n) {
        return (t - e) / (n - e) || 0
      }(t, e, n), i, r)
    }

    // openPrEntity
    class Kl {
      constructor(t) {
        this.props = t,
          this.init()
      }
      init() {
        const { maxAmount: t = 1e3, data: e = [], radius: n = 1, camera: i, maxIndexDistance: r, visibleIndex: s, colors: { openPrColor: o, openPrParticleColor: c } } = this.props
          , { pixelRatio: h, spikeRadius: u = .06 } = bl;
        this.mesh = new THREE.Group;
        const d = new THREE.MeshBasicMaterial({
          color: 65280,
          visible: !1
        })
          , f = new THREE.BoxBufferGeometry(.75, 1, .75);
        f.translate(0, .5, 0),
          f.rotateX(-Math.PI / 2);
        // 被隐藏的立方体
        const m = new THREE.InstancedMesh(f, d, t);
        this.mesh.add(m);
        const y = new THREE.MeshBasicMaterial({
          color: o,
          transparent: !0,
          opacity: .4,
          alphaTest: .05,
          blending: 2
        });
        y.onBeforeCompile = t => {
          t.uniforms.cameraPosition = {
            value: i.position
          },
            t.uniforms.radius = {
              value: n
            },
            t.uniforms.visibleIndex = {
              value: s
            },
            t.uniforms.maxIndexDistance = {
              value: r
            },
            t.uniforms.highlightIndex = {
              value: -9999
            },
            t.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float visibleIndex;\nuniform float maxIndexDistance;\n\nattribute float index;\n\nvarying float vScale;\nvarying float vIndex;\n\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nvoid main() {\n\tvIndex = index;\n\n\tvec3 pos = position;\n\n\tfloat scale = sineInOut(clamp(smoothstep(maxIndexDistance, 0.0, distance(index, visibleIndex)), 0., 1.));\n\tpos.z *= scale;\n\tvScale = scale;\n\n\tvec3 transformed = vec3( pos );\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n}",
            t.fragmentShader = "#define GLSLIFY 1\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n\nuniform float radius;\nuniform float visibleIndex;\nuniform float maxIndexDistance;\nuniform float highlightIndex;\n\nvarying float vScale;\nvarying float vIndex;\n\nvoid main() {\n\tif(vScale <= 0.01){\n\t\tdiscard;\n\t\treturn;\n\t}\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <alphatest_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\tvec3 rgb = outgoingLight.rgb;\n\tfloat alpha = diffuseColor.a;\n\n\t// highlight when mouse is over\n\tif(highlightIndex == vIndex){\n\t\trgb = vec3(1.0);\n\t\talpha = 1.0;\n\t}\n\n\tgl_FragColor = vec4( rgb, alpha );\n}",
            this.spikeUniforms = t.uniforms
        }
          ;
        const x = []
          , b = [];
        for (let U = 0; U < t; U++)
          x.push(U),
            b.push(U);
        // 点下的圆柱体
        const w = new THREE.CylinderBufferGeometry(u * h, u * h, 1, 6, 1, !1);
        w.setAttribute("index", new THREE.InstancedBufferAttribute(new Float32Array(x), 1)),
          w.translate(0, .5, 0),
          w.rotateX(-Math.PI / 2);
        const M = new THREE.InstancedMesh(w, y, t);
        this.mesh.add(M);
        const S = new THREE.BufferGeometry
          , E = []
          , T = []
          , A = new THREE.Color(c)
          , L = new THREE.Group
          , P = this.getDensities()
          , { densityValues: C, minDensity: R, maxDensity: I } = P;
        let D = 0;
        for (let U = 0; U < t; U++) {
          const t = e[U]
            , { gop: i } = t
            , r = i;
          Rl(r.lat, r.lon, n, L.position);
          const s = C[D++];
          L.scale.z = Dl(s, R, I, .05 * n, .2 * n),
            L.lookAt(wl),
            L.updateMatrix(),
            M.setMatrixAt(U, L.matrix),
            m.setMatrixAt(U, L.matrix),
            Rl(r.lat, r.lon, n + L.scale.z + .25, L.position),
            E.push(L.position.x, L.position.y, L.position.z),
            T.push(A.r, A.g, A.b)
        }
        S.setAttribute("position", new THREE.Float32BufferAttribute(E, 3).onUpload(function Il() {
          this.array = null
        })),
          S.setAttribute("color", new THREE.Float32BufferAttribute(T, 3).onUpload(function Il() {
            this.array = null
          })),
          S.setAttribute("index", new THREE.Float32BufferAttribute(b, 1).onUpload(function Il() {
            this.array = null
          }));
        const N = new THREE.PointsMaterial({
          alphaTest: .05,
          size: .8,
          depthWrite: !1
        });
        N.onBeforeCompile = t => {
          t.uniforms.cameraPosition = {
            value: i.position
          },
            t.uniforms.radius = {
              value: n
            },
            t.uniforms.visibleIndex = {
              value: s
            },
            t.uniforms.maxIndexDistance = {
              value: r
            },
            t.vertexShader = "#define GLSLIFY 1\nuniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nuniform float time;\nuniform float visibleIndex;\nuniform float maxIndexDistance;\nuniform float speed;\n\nattribute float index;\nattribute vec3 curveStart;\nattribute vec3 curveCtrl1;\nattribute vec3 curveCtrl2;\nattribute vec3 curveEnd;\nattribute float timeOffset;\n\nvarying float vAlpha;\n\nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nvec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n  vec3 E = mix(A, B, t);\n  vec3 F = mix(B, C, t);\n  vec3 G = mix(C, D, t);\n\n  vec3 H = mix(E, F, t);\n  vec3 I = mix(F, G, t);\n\n  vec3 P = mix(H, I, t);\n\n  return P;\n}\n\nvec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, vec3 E, float t) {\n  vec3 A1 = mix(A, B, t);\n  vec3 B1 = mix(B, C, t);\n  vec3 C1 = mix(C, D, t);\n  vec3 D1 = mix(D, E, t);\n\n  vec3 A2 = mix(A1, B1, t);\n  vec3 B2 = mix(B1, C1, t);\n  vec3 C2 = mix(C1, D1, t);\n\n  vec3 A3 = mix(A2, B2, t);\n  vec3 B3 = mix(B2, C2, t);\n  \n  vec3 P = mix(A3, B3, t);\n\n  return P;\n}\n\nvec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, vec3 E, vec3 F, float t) {\n  vec3 A1 = mix(A, B, t);\n  vec3 B1 = mix(B, C, t);\n  vec3 C1 = mix(C, D, t);\n  vec3 D1 = mix(D, E, t);\n  vec3 E1 = mix(E, F, t);\n\n  vec3 A2 = mix(A1, B1, t);\n  vec3 B2 = mix(B1, C1, t);\n  vec3 C2 = mix(C1, D1, t);\n  vec3 D2 = mix(D1, E1, t);\n\n  vec3 A3 = mix(A2, B2, t);\n  vec3 B3 = mix(B2, C2, t);\n  vec3 C3 = mix(C2, D2, t);\n\n  vec3 A4 = mix(A3, B3, t);\n  vec3 B4 = mix(B3, C3, t);\n  \n  vec3 P = mix(A4, B4, t);\n\n  return P;\n}\n\nvec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, vec3 E, vec3 F, vec3 G, float t) {\n  vec3 A1 = mix(A, B, t);\n  vec3 B1 = mix(B, C, t);\n  vec3 C1 = mix(C, D, t);\n  vec3 D1 = mix(D, E, t);\n  vec3 E1 = mix(E, F, t);\n  vec3 F1 = mix(F, G, t);\n\n  vec3 A2 = mix(A1, B1, t);\n  vec3 B2 = mix(B1, C1, t);\n  vec3 C2 = mix(C1, D1, t);\n  vec3 D2 = mix(D1, E1, t);\n  vec3 E2 = mix(E1, F1, t);\n\n  vec3 A3 = mix(A2, B2, t);\n  vec3 B3 = mix(B2, C2, t);\n  vec3 C3 = mix(C2, D2, t);\n  vec3 D3 = mix(D2, E2, t);\n\n  vec3 A4 = mix(A3, B3, t);\n  vec3 B4 = mix(B3, C3, t);\n  vec3 C4 = mix(C3, D3, t);\n\n  vec3 A5 = mix(A4, B4, t);\n  vec3 B5 = mix(B4, C4, t);\n  \n  vec3 P = mix(A5, B5, t);\n\n  return P;\n}\n\nvoid main() {    \n\t#include <color_vertex>\n\n\t// animate along curve and loop\n\tfloat t = quarticInOut(fract((time * speed + timeOffset)));\n\n\tvec3 pos = position;\n\n\t#ifdef USE_CURVE\n\t\tpos =  bezier(curveStart, curveCtrl1, curveCtrl2, curveEnd, t);\n\t#endif\n\n\tvec3 transformed = vec3( pos );\n\n\t// visible near visibleIndex\n\tfloat dist = distance(index, visibleIndex);\n\tvAlpha = smoothstep(maxIndexDistance * 0.75, 0.0, dist); // show after lines draw in (* 0.75)\n\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            t.fragmentShader = "#define GLSLIFY 1\nuniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform float radius;\nuniform float visibleIndex;\nuniform float maxIndexDistance;\n\nvarying vec3 vViewPosition;\nvarying float vAlpha;\n\n#define V0 vec3(0.0)\n\nvoid main() {\n\tif(vAlpha <= 0.05){\n\t\tdiscard;\n\t\treturn;\n\t}\n\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\t\n\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a * vAlpha );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            this.particleUniforms = t.uniforms
        }
          ;
        const O = new THREE.Points(S, N);
        this.mesh.add(O),
          this.materials = [y, N],
          this.spikes = M,
          this.spikeIntersects = m,
          this.particles = O,
          this.spikes.renderOrder = 3,
          this.particles.renderOrder = 4
      }
      getDensities() {
        const { data: t, maxAmount: e = 1e3, radius: n } = this.props
          , i = new THREE.Vector3
          , r = []
          , s = [];
        for (let h = 0; h < e; h++) {
          const e = t[h]
            , { gop: o } = e
            , c = o;
          c && c.lat && c.lon && (Rl(c.lat, c.lon, n, i),
            r.push((new THREE.Vector3).copy(i)),
            s.push(0))
        }
        let o = 99999
          , c = -1;
        return s.forEach((t => {
          t < o ? o = t : t > c && (c = t)
        }
        )),
        {
          densityValues: s,
          minDensity: o,
          maxDensity: c
        }
      }
      setHighlightIndex(t) {
        this.spikeUniforms && this.spikeUniforms.highlightIndex.value !== t && (this.spikeUniforms.highlightIndex.value = t)
      }
      update(t) {
        if (this.spikeUniforms && this.particleUniforms) {
          const { maxAmount: e, maxIndexDistance: n } = this.props;
          this.spikeUniforms && (this.spikeUniforms.visibleIndex.value = t),
            this.particleUniforms && (this.particleUniforms.visibleIndex.value = t);
          const i = Nl(t - n | 0, 0, e)
            , r = 2 * n | 0
            , s = Nl(i + r, 0, e);
          this.spikes.count = s,
            this.particles.geometry.setDrawRange(i, r)
        }
      }
      dispose() {
        this.mesh && Pl(this.mesh, Ll),
          this.mesh && this.mesh.parent && this.mesh.parent.remove(this.mesh),
          this.props = null,
          this.mesh = null,
          this.spikeUniforms = null,
          this.particleUniforms = null,
          this.materials = null,
          this.spikes = null,
          this.particles = null
      }
    }
  </script>
</body>

</html>